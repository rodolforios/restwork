// Generated by CoffeeScript 1.9.3
(function() {
  'use strict';
  var MySQLConnector, expect;

  MySQLConnector = require('../../src/connectors/MySQLConnector');

  expect = require('expect.js');

  describe('the MySQLConnector,', function() {
    describe('when creating a new instance', function() {
      it('should throw an exception if one or more params was not passed', function() {
        return expect(function() {
          return new MySQLConnector({});
        }).to.throwError(function(e) {
          expect(e.type).to.be('Fatal');
          expect(e.name).to.be('Invalid argument');
          return expect(e.message).to.be('Missing one or more arguments');
        });
      });
      return it('should verify if the connection pool was created', function() {
        var connector, createPoolCalled, deps, expectedParams, params;
        createPoolCalled = false;
        params = {
          host: 'host',
          poolSize: 10000,
          timeout: 10000,
          user: 'user',
          password: 'password',
          domain: 'databaseName',
          resource: 'tableName'
        };
        expectedParams = {
          host: params.host,
          database: params.domain,
          user: params.user,
          password: params.password,
          connectionLimit: params.poolSize,
          acquireTimeout: params.timeout,
          waitForConnections: 0
        };
        deps = {
          mysql: {
            createPool: function(params) {
              expect(params).to.eql(expectedParams);
              return createPoolCalled = true;
            }
          }
        };
        connector = new MySQLConnector(params, deps);
        expect(connector).to.be.ok();
        expect(connector.pool).to.be.ok();
        return expect(createPoolCalled).to.be.ok();
      });
    });
    return describe('when reading a order', function() {
      var params;
      params = null;
      beforeEach(function() {
        return params = {
          host: 'host',
          poolSize: 10000,
          timeout: 10000,
          user: 'user',
          password: 'password',
          domain: 'databaseName',
          resource: 'tableName'
        };
      });
      it('should return an error if the order id is null', function(done) {
        var connector, expectedError;
        expectedError = 'Invalid id';
        connector = new MySQLConnector(params);
        return connector.read(null, function(error, response) {
          expect(error).to.eql(expectedError);
          expect(response).not.to.be.ok();
          return done();
        });
      });
      it('should return an error if the order id is undefined', function(done) {
        var connector, expectedError;
        expectedError = 'Invalid id';
        connector = new MySQLConnector(params);
        return connector.read(void 0, function(error, response) {
          expect(error).to.eql(expectedError);
          expect(response).not.to.be.ok();
          return done();
        });
      });
      it('should return an error if the order id is zero', function(done) {
        var connector, expectedError;
        expectedError = 'Invalid id';
        connector = new MySQLConnector(params);
        return connector.read(0, function(error, response) {
          expect(error).to.eql(expectedError);
          expect(response).not.to.be.ok();
          return done();
        });
      });
      it('should return an ', function(done) {
        var connector, deps, expectedError;
        expectedError = 'Error getConnection';
        deps = {
          mysql: {
            createPool: function(params) {
              return {
                getConnection: function(callback) {
                  return callback('Error to get connection');
                }
              };
            }
          }
        };
        connector = new MySQLConnector(params, deps);
        return connector.read(1, function(error, response) {
          expect(error).to.eql(expectedError);
          expect(response).not.to.be.ok();
          return done();
        });
      });
      it('should return the query error if it happens', function(done) {
        var connector, deps, expectedError, mockedConnection, releaseMethodCalled;
        releaseMethodCalled = false;
        expectedError = 'Error Query';
        mockedConnection = {
          query: function(query, params, callback) {
            return callback(expectedError);
          },
          release: function() {
            return releaseMethodCalled = true;
          }
        };
        deps = {
          mysql: {
            createPool: function(params) {
              return {
                getConnection: function(callback) {
                  return callback(null, mockedConnection);
                }
              };
            }
          }
        };
        connector = new MySQLConnector(params, deps);
        connector._selectDatabase = function(databaseName, connection, callback) {
          return callback();
        };
        return connector.read(1, function(error, response) {
          expect(error).to.eql(expectedError);
          expect(response).not.to.be.ok();
          expect(releaseMethodCalled).to.be(true);
          return done();
        });
      });
      it('should return the found row', function(done) {
        var connector, deps, expectedRow, mockedConnection;
        expectedRow = {
          costumer_number: 1,
          amount: 100
        };
        mockedConnection = {
          query: function(query, params, callback) {
            return callback(null, expectedRow);
          },
          release: function() {}
        };
        deps = {
          mysql: {
            createPool: function(params) {
              return {
                getConnection: function(callback) {
                  return callback(null, mockedConnection);
                }
              };
            }
          }
        };
        connector = new MySQLConnector(params, deps);
        return connector.read(1, function(error, response) {
          expect(error).not.to.be.ok();
          expect(response).to.eql(expectedRow);
          return done();
        });
      });
      it('should return a NOT_FOUND error if nothing was found', function(done) {
        var connector, deps, expectedRow, mockedConnection;
        expectedRow = {
          costumer_number: 1,
          amount: 100
        };
        mockedConnection = {
          query: function(query, params, callback) {
            return callback();
          },
          release: function() {}
        };
        deps = {
          mysql: {
            createPool: function(params) {
              return {
                getConnection: function(callback) {
                  return callback(null, mockedConnection);
                }
              };
            }
          }
        };
        connector = new MySQLConnector(params, deps);
        return connector.read(1, function(error, response) {
          expect(error).not.to.be('NOT FOUND');
          expect(response).not.to.be.ok();
          return done();
        });
      });
      return it('should return an error if the database selection went wrong', function(done) {
        var connector, deps, expectedError, mockedConnection;
        expectedError = 'Error select database';
        mockedConnection = {
          query: function(query, params, callback) {
            return callback();
          },
          release: function() {}
        };
        deps = {
          mysql: {
            createPool: function(params) {
              return {
                getConnection: function(callback) {
                  return callback(null, mockedConnection);
                }
              };
            }
          }
        };
        connector = new MySQLConnector(params, deps);
        connector._selectDatabase = function(databaseName, connection, callback) {
          return callback(expectedError);
        };
        return connector.read(1, function(error, response) {
          expect(error).to.eql(expectedError);
          expect(response).not.to.be.ok();
          return done();
        });
      });
    });
  });

}).call(this);
